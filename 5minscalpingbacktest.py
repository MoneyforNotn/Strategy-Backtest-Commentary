# -*- coding: utf-8 -*-
"""5MinScalpingBACKTEST.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M39N8IlqCs3vhi8nOobWWgT8_Zkmews6
"""

#5 min Scapling VWAP


#COMPLETE BACKTEST + OPTIMIZATION

"""https://www.youtube.com/watch?v=RbQaARxEW9o"""

#previous 15 candles must close above the vwap curve for long trades, oposite for short trades
#set bollinger bands (lenght 14, std 2)
#price must close below lower bollinger band for long position
#RSI for confirmation (RSI <45 buy signal, rsi>55 sell), if this all is true enter trade

#SL = a x ATR  (7 or 8)
#TP = Ratio x SL (ratio to be coded, atr, a, also parameters to be changed)
# so far the best optimizer
# SL atr = 1.3
# tpslr = 1.9

import sys
print(sys.version)

import numpy as np
print(np.__version__)

!pip install numpy==1.23.5

!pip install -U git+https://github.com/twopirllc/pandas-ta
import pandas_ta as ta

import pandas as pd
#df=pd.read_csv("AAPL_5M_BID_2024-2025.csv")
df=pd.read_csv("EURUSD_Candlestick_5_M_ASK_30.09.2019-30.09.2022.csv")
df

print(df.columns)

df["Gmt time"]=df["Gmt time"].str.replace(".000","")
df["Gmt time"]=pd.to_datetime(df["Gmt time"],format='%d.%m.%Y %H:%M:%S')
df.set_index("Gmt time",inplace=True)
df=df[df.High!=df.Low] #discarting days where low=high (no movement)
len(df)

# df["Date"] = df["Date"].str.replace(r"-0\d:00$", "", regex=True)
# df["Date"] = pd.to_datetime(df["Date"], format='%Y-%m-%d %H:%M:%S', errors='coerce')
# df.set_index("Date",inplace=True)
# df=df[df.High!=df.Low] #discarting days where low=high (no movement)
# len(df)

# df["Datetime"]=df["Datetime"].str.replace(r"-0\d:00$", "", regex=True)
# df["Datetime"]=pd.to_datetime(df["Datetime"],format='%Y-%m-%d %H:%M:%S')
# df.set_index("Datetime",inplace=True)
# df=df[df.High!=df.Low] #discarting days where low=high (no movement)
# len(df)

# #dukascopy
# df["Local time"] = df["Local time"].str.replace(r"-0\d:00$", "", regex=True) # Remove timezone offsets
# df["Local time"] = df["Local time"].str.replace(".000", "", regex=True)  # Remove ".000"

# #The problem is that the format is inconsistent, with some strings having 'GMT-0500'
# #at the end. We will split the string at the first space character to get the portion we need
# df["Local time"] = df["Local time"].str.split(' ').str[0]
# df["Local time"] = pd.to_datetime(df["Local time"], format='%d.%m.%Y% H:%M:%S') # Now this should work
# df.set_index("Local time", inplace=True)
# df = df[df.High != df.Low]  # Discarding days where low=high (no movement)
# len(df)

df["VWAP"]=ta.vwap(df.High,df.Low,df.Close,df.Volume, offset=25)
df["RSI"]=ta.rsi(df.Close,length=16)#16
my_bbands=ta.bbands(df.Close,length=14,std=2)#14
df=df.join(my_bbands)
df.dropna(inplace=True)

VWAPsignal = [0]*len(df)
backcandles = 15 #defval 15

#from comments
df['Max_Open_Close'] = df[['Open','Close']].max(axis=1)
df['Min_Open_Close'] = df[['Open','Close']].min(axis=1)
df['upt'] = 1
df['dnt'] = 1
df.loc[(df['Max_Open_Close'] >= df['VWAP']), 'dnt'] = 0
df.loc[(df['Min_Open_Close'] <= df['VWAP']), 'upt'] = 0
df['sig_dnt'] = df['dnt'].rolling(backcandles + 1, min_periods=1).min()
df['sig_upt'] = df['upt'].rolling(backcandles + 1, min_periods=1).min()
df['VWAPSignal'] = 0
df.loc[(df['sig_upt'] == 1) & (df['sig_dnt'] == 1), 'VWAPSignal'] = 3
df.loc[(df['sig_upt'] == 1) & (df['sig_dnt'] == 0), 'VWAPSignal'] = 2
df.loc[(df['sig_upt'] == 0) & (df['sig_dnt'] == 1), 'VWAPSignal'] = 1

# VWAPsignal = [0]*len(df)
# backcandles = 15

# for row in range(backcandles,len(df)):
#   upt = 1
#   dnt = 1
#   for i in range(row-backcandles,row+1):
#      if max(df.Open[i], df.Close[i]) >=df.VWAP[i]:
#            dnt = 0
#      if min(df.Open[i], df.Close[i]) <=df.VWAP[i]:
#             upt = 0
#   if upt == 1 and dnt == 1:
#         VWAPsignal[row] = 3
#   elif upt == 1:
#         VWAPsignal[row] = 2
#   elif dnt == 1:
#         VWAPsignal[row] = 1

# df['VWAPSignal'] = VWAPsignal

def calculate_total_signal(l):
    if (df.VWAPSignal[l]==2
        and df.Close[l]<=df['BBL_14_2.0'][l]
        and df.RSI[l]<45):#45
        return 2
    if (df.VWAPSignal[l]==1
        and df.Close[l]>=df['BBU_14_2.0'][l]
        and df.RSI[l]>55):
        return 1
    else:
        return 0

total_signals = [0]*len(df) # Changed variable name to avoid conflict
for row in range(backcandles,len(df)):
    total_signals[row] = calculate_total_signal(row) # Call the function using the new name
df['TotalSignal'] = total_signals # Assign the list to the DataFrame column
# TotalSignal = [0]*len(df)
# for row in range(backcandles,len(df)):
#     TotalSignal[row] = TotalSignal(row)
# df['TotalSignal'] = TotalSignal

df[df.TotalSignal!=0].count()
#2781 in video

import numpy as np
def pointposbreak(x):
  if x['TotalSignal']==1:
    return x['High']+1e-4
  elif x['TotalSignal']==2:
    return x['Low']-1e-4
  else:
    return np.nan

df['pointposbreak']=df.apply(lambda row: pointposbreak(row) ,axis=1)

import plotly.graph_objects as go
from plotly.subplots import make_subplots
from datetime import datetime
st=10400
dfpl=df[st:st+350]
dfpl.reset_index(inplace=True)
fig = go.Figure(data=[go.Candlestick(x=dfpl.index,
                open=dfpl['Open'],
                high=dfpl['High'],
                low=dfpl['Low'],
                close=dfpl['Close']),
                go.Scatter(x=dfpl.index, y=dfpl.VWAP,#['VWAP']
                           line=dict(color='blue', width=1), name='VWAP'),
                go.Scatter(x=dfpl.index, y=dfpl['BBL_14_2.0'],line=dict(color='green',width=1),name="BBL"), # Added comma here
                go.Scatter(x=dfpl.index, y=dfpl['BBU_14_2.0'],line=dict(color='green',width=1),name="BBU")]) # Added comma here

fig.add_scatter(x=dfpl.index, y=dfpl['pointposbreak'], mode="markers", marker=dict(color="MediumPurple", size=5),name="Signal")
#fig.show()

dfpl=df[:225000].copy()
import pandas_ta as ta
dfpl["ATR"]=ta.atr(dfpl.High, dfpl.Low, dfpl.Close, length=7)
#help(ta.atr)
def SIGNAL():
    return dfpl.TotalSignal

!pip install backtesting

# from backtesting import Strategy
# from backtesting import Backtest

# class MyStrategy(Strategy):
#     initsize = 0.99
#     mysize = initsize
#     def init(self):
#         super().init()
#         self.signal = self.I(SIGNAL)

#     def next(self):
#         super().next()
#         slatr = 1.2*self.data.ATR[-1]
#         TPSLRatio = 1.5

#         if len(self.trades)>0:
#           if self.trades[-1].is_long and self.data.RSI[-1]>=90:
#             self.trades[-1].close()
#           elif self.trades[-1].is_short and self.data.RSI[-1]<=10:
#             self.trades[-1].close()

#           if self.signal1==2 and len(self.trades)==0:
#               sl1=self.data.Close[-1]-slatr
#               tp1=self.data.Close[-1]+slatr*TPSLRatio
#               self.buy(sl=sl1,tp=tp1,size=self.mysize)

#           elif self.signal1==1 and len(self.trades)==0:
#               sl1=self.data.Close[-1]+slatr
#               tp1=self.data.Close[-1]-slatr*TPSLRatio
#               self.sell(sl=sl1,tp=tp1,size=self.mysize)

# bt = Backtest(dfpl, MyStrategy, cash=10000, margin=1/10, commission=0.00)
# stat=bt.run()
# stat

from backtesting import Strategy, Backtest



class MyStrategy(Strategy):
    initsize = 0.99
    mysize = initsize
    x = 1.2  # Define slatr as a class variable
    y = 1.5  # Define TPSLRatio as a class variable
#ATR = 7

    def init(self):
        super().init()
        self.signal = self.I(SIGNAL)  # Ensure SIGNAL is defined externally

    def next(self):
        super().next()
        slatr = self.x * self.data.ATR[-1]  # Stop-loss ATR calculation
        TPSLRatio = self.y

        # Ensure signal1 is correctly referenced
        signal1 = self.signal[-1]

        # Check if there's an open trade and close based on RSI conditions
        if len(self.trades) > 0:
            last_trade = self.trades[-1]  # Get the last active trade

            if last_trade.is_long and self.data.RSI[-1] >= 90:
                last_trade.close()
            elif last_trade.is_short and self.data.RSI[-1] <= 10:
                last_trade.close()

        # Entry conditions: only trade when there are no open positions
        if len(self.trades) == 0:
            if signal1 == 2:
                sl1 = self.data.Close[-1] - slatr
                tp1 = self.data.Close[-1] + slatr * TPSLRatio
                self.buy(sl=sl1, tp=tp1, size=self.mysize)

            elif signal1 == 1:
                sl1 = self.data.Close[-1] + slatr
                tp1 = self.data.Close[-1] - slatr * TPSLRatio
                self.sell(sl=sl1, tp=tp1, size=self.mysize)

# Running the backtest
bt = Backtest(dfpl, MyStrategy, cash=10000, margin=1/10, commission=0.00)
stat = bt.run()
stat

bt.plot()



"""Run the 2nd optimizer"""

# stats = bt.optimize(
#     x=np.arange(0.6, 1.7, 0.1).tolist(),  # Optimize stop-loss ATR multiplier from 1 to 4
#     maximize="Sharpe Ratio",  # Maximize Sharpe Ratio instead of final equity
#     constraint=lambda p: p.x >= 0.5  # Ensure stop-loss multiplier is at least 1
# )
# stats

stats['_strategy']

import seaborn as sns
import matplotlib.pyplot as plt

stats, heatmap = bt.optimize(
    x=np.arange(1.4, 2.1, 0.1).tolist(),  # Testing different Stop-Loss ATR multipliers
    y=np.arange(1.4, 2.4, 0.1).tolist(),  # Testing different Take-Profit/Stop-Loss Ratios
    #x=np.arange(0.9, 1.2, 0.1).tolist(),  # Testing different Stop-Loss ATR multipliers
    #y=np.arange(1.4, 1.7, 0.1).tolist(),
    maximize="Equity Final [$]",  # Optimize for highest final equity
    #maximize="Sharpe Ratio",  # Maximize Sharpe Ratio instead of final equity
  #  constraint=lambda p: p.y>p.x,  # Ensure logical values
    return_heatmap=True  # Return the heatmap for further analysis
  )

print(stats)
bt.plot()

import seaborn as sns
import matplotlib.pyplot as plt


heatmap_df = heatmap.unstack()
plt.figure(figsize=(8, 6))
sns.heatmap(heatmap_df, annot=True, fmt=".0f", cmap="viridis")
plt.show()

# df_results = pd.DataFrame([{k: v for k, v in vars(stats._strategy).items() if k != '_equity_curve'}])

# # Pivot the data for heatmap
# heatmap_data = df_results.pivot(index='x', columns='y')

# # Plot the heatmap
# plt.figure(figsize=(8,6))
# sns.heatmap(heatmap_data, annot=True, fmt=".0f", cmap="coolwarm", linewidths=0.5)

plt.title("Optimization Heatmap of Stop-Loss ATR vs TP/SL Ratio")
plt.xlabel("Take-Profit / Stop-Loss Ratio (y)")
plt.ylabel("Stop-Loss ATR Multiplier (x)")
plt.show()


# # Create a dictionary to store the optimization results
# heatmap_data_dict = {'x': [], 'y': [], 'Equity Final [$]': []}

# # Iterate through the optimization results grid
# for x in stats._strategy.params['x'].unique():  # Get unique x values
#     for y in stats._strategy.params['y'].unique():  # Get unique y values
#         # Filter the results for the current (x, y) combination
#         filtered_stats = stats._strategy.params[(stats._strategy.params['x'] == x) & (stats._strategy.params['y'] == y)]

#         # Extract the desired metric (e.g., 'Equity Final [$]')
#         equity_final = filtered_stats['Equity Final [$]'].iloc[0]

#         # Append the data to the dictionary
#         heatmap_data_dict['x'].append(x)
#         heatmap_data_dict['y'].append(y)
#         heatmap_data_dict['Equity Final [$]'].append(equity_final)

# # Convert the dictionary to a DataFrame
# heatmap_data = pd.DataFrame(heatmap_data_dict).pivot(index='x', columns='y', values='Equity Final [$]')

# # Plot the heatmap
# plt.figure(figsize=(8, 6))
# sns.heatmap(heatmap_data, annot=True, fmt=".0f", cmap="coolwarm", linewidths=0.5)
# plt.title("Optimization Heatmap of Stop-Loss ATR vs TP/SL Ratio")
# plt.xlabel("Take-Profit / Stop-Loss Ratio (y)")
# plt.ylabel("Stop-Loss ATR Multiplier (x)")
# plt.show()

stats['_strategy']





